/** This server return data produce by a generator function as stream */
import { createServer, IncomingMessage, ServerResponse} from 'node:http'
import { randomUUID } from 'node:crypto'
import { Readable } from 'node:stream'

// Compose Types
type Title = string
type Name = string
type Value = number
type Unit = string
type Description = string

// Enum
enum Status {
  Draft = 0,
  Reviewed = 1,
  Approved = 2,
  Published = 3
}

// Interfaces
interface ReportInterface<T> {
  title: Title,
  data: T[],
  createAt: Date,
  // getTitle: () => Title
  // setTitle: (title: Title) => Title
  // getData: () => ReportDataInterface[]
  // setData: (data: ReportDataInterface[]) => ReportDataInterface[]
}
interface ReportDataInterface {
  name: Name,
  value: Value,
  unit: Unit,
  description: Description,
  status: Status  
  // getName: () => Name
  // setName: (name: Name) => Name
  // getValue: () => Value
  // setValue: (value: Value) => Value
  // getDescription: () => Description
  // setDescription: (description: Description) => Description
  // getStatus: () => Status
  // setStatus: (status: Status) => Status
}

// Classes
class Report implements ReportInterface<ReportDataInterface> {
  title: Title
  data: ReportDataInterface[]
  createAt: Date


  constructor(title: Title, data: ReportDataInterface[] ) {
    this.title = title
    this.data = data
    this.createAt = new Date()
  }

  getTitle = (): Title => {
    return this.title
  }

  setTitle = (title: Title) => {
    this.title = title
  }

  getData = (): ReportDataInterface[] => {
    return this.data
  }

  setData = (data: ReportDataInterface[]) => {
    this.data = data
  }

}

class ReportData implements ReportDataInterface {
  name: Name
  value: Value
  unit: Unit
  description: Description
  status: Status 

  constructor (name: Name, value: Value, unit: Unit = '', description: Description = '', status: Status = Status.Draft) {
    this.name = name
    this.value = value
    this.unit = unit
    this.description = description
    this.status = status
  }

  getName = () => {
    return this.name
  }

  setName = (name: Name) => {
    this.name = name
  }

  getValue = () => {}

  setValue = (value: Value) => {
    this.value = value
  }

  getDescription = () => {}

  setDescription = (description: Description) => {
    this.description = description
  }

  getStatus = () => {}
  setStatus = (status: Status) => {
    this.status = status
  }



}

// Generate reports on demand with a generator object
function* generateReports () {

  for(let index = 0; index < 1000; index++){
    let report = new Report(`Report #${randomUUID()}`, [
      new ReportData('Number of promoters', 100 * index),
      new ReportData('Number of consumers', 1_000_000 * index),
      new ReportData('Number of campaigns', 1_000 * index),
    ])

    yield report
  }

}

const requestHandler = (request: IncomingMessage, response: ServerResponse) => {
  switch(request.url){
    case '/':
      response.statusCode = 200
      response.end(JSON.stringify({
        data: 'Welcome, the stream server is healthy!'
      }))
      break;
    case '/reports':
      if(request.method === 'GET'){
        response.statusCode = 200
        // Create a readable stream for the stream of reports data generated by *generateReports()
        const readableStream = new Readable ({
          read(){
            for(const report of generateReports()){
              this.push(JSON.stringify(report).concat('\n'))
            }
            // Indicate the end of the stream
            this.push(null) 
          }
        })
        // Pipe it to response
        readableStream.pipe(response)
      }
      break;
    default:
      response.statusCode = 404
      response.end(JSON.stringify({
        data: '404 - Not Found'
      }))
      break;
  }
}

createServer(requestHandler)
.listen(4999)
.on('listening', () => console.log('Listening to node stream server on 4999'))
.on('error',  (err) => console.log(`Error on stream server ${err}`))